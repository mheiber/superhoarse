import XCTest
import Foundation
import Combine
import SwiftUI
@testable import SuperWhisperLite

final class AccessibilityUITests: XCTestCase {
    var appState: AppState!
    var cancellables: Set<AnyCancellable>!
    
    override func setUpWithError() throws {
        appState = AppState()
        cancellables = Set<AnyCancellable>()
    }
    
    override func tearDownWithError() throws {
        appState = nil
        cancellables = nil
    }
    
    // MARK: - Accessibility Permission Flow Tests
    
    func testAccessibilityPermissionInitialState() {
        // Test that accessibility permission state is properly detected
        // Note: This will vary based on system settings
        
        let initialPermissionState = appState.hasAccessibilityPermission
        
        // State should be consistent
        XCTAssertNotNil(initialPermissionState)
        
        // Permission checking should not crash
        appState.requestAccessibilityPermissions()
        XCTAssertTrue(true) // If we get here, no crash occurred
    }
    
    func testAccessibilityPermissionStateChanges() {
        // Test that accessibility permission changes are observable
        
        let permissionStateObserved = XCTestExpectation(description: "Permission state observed")
        
        appState.$hasAccessibilityPermission
            .sink { hasPermission in
                // Just observing the state is enough - actual value depends on system
                permissionStateObserved.fulfill()
            }
            .store(in: &cancellables)
        
        wait(for: [permissionStateObserved], timeout: 1.0)
    }
    
    func testTranscriptionWorkflowWithoutAccessibilityPermission() {
        // Test that app works even without accessibility permission
        // (should still copy to clipboard)
        
        let transcriptionUpdated = XCTestExpectation(description: "Transcription updated")
        
        // Simulate no accessibility permission
        appState.setValue(false, forKey: "hasAccessibilityPermission")
        
        appState.$transcriptionText
            .dropFirst()
            .sink { text in
                if !text.isEmpty {
                    transcriptionUpdated.fulfill()
                }
            }
            .store(in: &cancellables)
        
        // Simulate a complete recording -> transcription workflow
        appState.toggleRecording()
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
            self.appState.toggleRecording()
            
            // Simulate transcription result
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.appState.setValue("Test transcription", forKey: "transcriptionText")
            }
        }
        
        wait(for: [transcriptionUpdated], timeout: 2.0)
        
        // App should work normally even without accessibility permission
        XCTAssertEqual(appState.transcriptionText, "Test transcription")
        XCTAssertFalse(appState.hasAccessibilityPermission)
    }
    
    func testAccessibilityPermissionRequestFlow() {
        // Test the user flow when requesting accessibility permissions
        
        let requestCompleted = XCTestExpectation(description: "Permission request completed")
        
        // Monitor state changes during permission request
        var stateChanges: [String] = []
        
        appState.$hasAccessibilityPermission
            .sink { hasPermission in
                stateChanges.append("hasAccessibilityPermission: \(hasPermission)")
                if stateChanges.count >= 1 {
                    requestCompleted.fulfill()
                }
            }
            .store(in: &cancellables)
        
        // Request permissions (this might show system dialog in real usage)
        appState.requestAccessibilityPermissions()
        
        wait(for: [requestCompleted], timeout: 3.0)
        
        // Should have at least observed the initial state
        XCTAssertGreaterThanOrEqual(stateChanges.count, 1)
    }
    
    // MARK: - UI Component Integration Tests
    
    func testContentViewStateBinding() {
        // Test that ContentView correctly responds to AppState changes
        
        // Test recording state affects UI
        XCTAssertFalse(appState.isRecording)
        XCTAssertFalse(appState.showListeningIndicator)
        
        appState.toggleRecording()
        
        XCTAssertTrue(appState.isRecording)
        XCTAssertTrue(appState.showListeningIndicator)
        
        appState.toggleRecording()
        
        XCTAssertFalse(appState.isRecording)
        XCTAssertFalse(appState.showListeningIndicator)
    }
    
    func testListeningIndicatorViewIntegration() {
        // Test listening indicator integration with app state
        
        let indicatorStateChangeExpectation = XCTestExpectation(description: "Indicator state changes")
        
        var indicatorShownStates: [Bool] = []
        
        appState.$showListeningIndicator
            .sink { showing in
                indicatorShownStates.append(showing)
                if indicatorShownStates.count >= 3 { // initial false, true, false
                    indicatorStateChangeExpectation.fulfill()
                }
            }
            .store(in: &cancellables)
        
        // Simulate user interaction that would show/hide indicator
        appState.toggleRecording() // Should show indicator
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            self.appState.hideListeningIndicator() // User manually hides
        }
        
        wait(for: [indicatorStateChangeExpectation], timeout: 2.0)
        
        XCTAssertEqual(indicatorShownStates, [false, true, false])
    }
    
    func testWaveformVisualizerIntegration() {
        // Test that waveform visualizer responds to audio levels
        
        let audioLevelChanges = XCTestExpectation(description: "Audio level changes detected")
        
        var levelUpdates = 0
        
        appState.audioRecorder?.$currentAudioLevel
            .sink { level in
                levelUpdates += 1
                if levelUpdates >= 5 {
                    audioLevelChanges.fulfill()
                }
            }
            .store(in: &cancellables)
        
        // Start recording to begin audio level monitoring
        appState.toggleRecording()
        
        wait(for: [audioLevelChanges], timeout: 2.0)
        
        // Should have received multiple level updates
        XCTAssertGreaterThanOrEqual(levelUpdates, 5)
        
        // Clean up
        appState.toggleRecording()
    }
    
    // MARK: - User Interaction Simulation Tests
    
    func testCompleteUserJourneyFromColdStart() {
        // Test complete user journey from app start to successful transcription
        
        let journeyCompleted = XCTestExpectation(description: "Complete user journey")
        
        var journeySteps: [String] = []
        
        // Track the complete user journey
        appState.$isInitialized
            .sink { initialized in
                if initialized {
                    journeySteps.append("App initialized")
                }
            }
            .store(in: &cancellables)
        
        appState.$isRecording
            .sink { recording in
                if recording {
                    journeySteps.append("Recording started")
                } else if journeySteps.contains("Recording started") {
                    journeySteps.append("Recording stopped")
                }
            }
            .store(in: &cancellables)
        
        appState.$showListeningIndicator
            .sink { showing in
                if showing {
                    journeySteps.append("Indicator shown")
                } else if journeySteps.contains("Indicator shown") {
                    journeySteps.append("Indicator hidden")
                }
            }
            .store(in: &cancellables)
        
        appState.$transcriptionText
            .sink { text in
                if !text.isEmpty {
                    journeySteps.append("Transcription received")
                    journeyCompleted.fulfill()
                }
            }
            .store(in: &cancellables)
        
        // Simulate complete user workflow
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            // User presses hotkey to start recording
            self.appState.toggleRecording()
        }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            // User presses hotkey again to stop recording
            self.appState.toggleRecording()
        }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.7) {
            // Simulate transcription result arriving
            self.appState.setValue("Hello world", forKey: "transcriptionText")
        }
        
        wait(for: [journeyCompleted], timeout: 5.0)
        
        // Verify complete journey happened
        let expectedSteps = [
            "App initialized",
            "Recording started",
            "Indicator shown",
            "Recording stopped",
            "Indicator hidden",
            "Transcription received"
        ]
        
        for step in expectedSteps {
            XCTAssertTrue(journeySteps.contains(step), "Missing journey step: \(step)")
        }
    }
    
    func testUserInterruptedRecordingSession() {
        // Test user interrupting recording session (closing app, system interruption, etc.)
        
        let interruptionHandled = XCTestExpectation(description: "Interruption handled gracefully")
        
        appState.toggleRecording()
        XCTAssertTrue(appState.isRecording)
        XCTAssertTrue(appState.showListeningIndicator)
        
        // Simulate app interruption or user closing app
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
            // Force stop recording (simulate interruption)
            self.appState.setValue(false, forKey: "isRecording")
            self.appState.setValue(false, forKey: "showListeningIndicator")
            interruptionHandled.fulfill()
        }
        
        wait(for: [interruptionHandled], timeout: 1.0)
        
        // App should handle interruption gracefully
        XCTAssertFalse(appState.isRecording)
        XCTAssertFalse(appState.showListeningIndicator)
    }
    
    // MARK: - Edge Case UI Tests
    
    func testUIConsistencyWithRapidStateChanges() {
        // Test UI remains consistent with rapid state changes
        
        let consistencyTestCompleted = XCTestExpectation(description: "Consistency test completed")
        
        var stateSnapshot: [String: Any] = [:]
        var inconsistentStates: [String] = []
        
        // Monitor for inconsistent states
        let timer = Timer.scheduledTimer(withTimeInterval: 0.05, repeats: true) { _ in
            let currentSnapshot: [String: Any] = [
                "isRecording": self.appState.isRecording,
                "showListeningIndicator": self.appState.showListeningIndicator,
                "transcriptionText": self.appState.transcriptionText
            ]
            
            // Check for logical inconsistencies
            let isRecording = currentSnapshot["isRecording"] as! Bool
            let showIndicator = currentSnapshot["showListeningIndicator"] as! Bool
            
            // These states should be logically consistent
            if !isRecording && showIndicator {
                inconsistentStates.append("Indicator showing but not recording")
            }
            
            stateSnapshot = currentSnapshot
        }
        
        // Perform rapid state changes
        for i in 0..<20 {
            DispatchQueue.main.asyncAfter(deadline: .now() + Double(i) * 0.02) {
                self.appState.toggleRecording()
                
                if i == 19 {
                    timer.invalidate()
                    consistencyTestCompleted.fulfill()
                }
            }
        }
        
        wait(for: [consistencyTestCompleted], timeout: 3.0)
        
        // Should have minimal or no inconsistent states
        XCTAssertLessThanOrEqual(inconsistentStates.count, 2, "Too many inconsistent states: \(inconsistentStates)")
    }
    
    func testKeyboardShortcutStringFormattingEdgeCases() {
        // Test keyboard shortcut display with various configurations
        
        let testCases: [(modifier: Int, key: Int, expected: String)] = [
            (0, 49, "⌘⇧Space"),     // Default
            (1, 15, "⌘⌥R"),         // Cmd+Option+R
            (2, 17, "⌘⌃T"),         // Cmd+Control+T
            (3, 46, "⌥⇧M"),         // Option+Shift+M
            (0, 9, "⌘⇧V"),          // Cmd+Shift+V
            (1, 999, "⌘⌥Key(999)")  // Unknown key code
        ]
        
        for testCase in testCases {
            UserDefaults.standard.set(testCase.modifier, forKey: "hotKeyModifier")
            UserDefaults.standard.set(testCase.key, forKey: "hotKeyCode")
            
            let shortcutString = appState.getCurrentShortcutString()
            XCTAssertEqual(shortcutString, testCase.expected, 
                          "Modifier: \(testCase.modifier), Key: \(testCase.key)")
        }
        
        // Cleanup
        UserDefaults.standard.removeObject(forKey: "hotKeyModifier")
        UserDefaults.standard.removeObject(forKey: "hotKeyCode")
    }
    
    // MARK: - Performance and Responsiveness Tests
    
    func testUIResponsivenessDuringAudioLevelUpdates() {
        // Test that frequent audio level updates don't block UI
        
        let responsivenessTestCompleted = XCTestExpectation(description: "Responsiveness test completed")
        
        var uiUpdateCount = 0
        let targetUIUpdates = 50
        
        appState.toggleRecording() // Start audio level monitoring
        
        // Simulate frequent UI queries while audio levels are updating
        let timer = Timer.scheduledTimer(withTimeInterval: 0.02, repeats: true) { _ in
            // Simulate UI queries that would happen during recording
            let _ = self.appState.isRecording
            let _ = self.appState.showListeningIndicator
            let _ = self.appState.getCurrentShortcutString()
            let _ = self.appState.audioRecorder?.currentAudioLevel ?? 0.0
            
            uiUpdateCount += 1
            
            if uiUpdateCount >= targetUIUpdates {
                self.appState.toggleRecording() // Stop recording
                responsivenessTestCompleted.fulfill()
            }
        }
        
        wait(for: [responsivenessTestCompleted], timeout: 3.0)
        
        timer.invalidate()
        
        // Should have completed all UI updates without blocking
        XCTAssertGreaterThanOrEqual(uiUpdateCount, targetUIUpdates)
        XCTAssertFalse(appState.isRecording)
    }
    
    func testMemoryUsageDuringExtendedUIInteraction() {
        // Test memory stability during extended UI interaction
        
        let memoryTestCompleted = XCTestExpectation(description: "Memory test completed")
        
        var interactionCount = 0
        let targetInteractions = 100
        
        func performUIInteraction() {
            // Simulate various UI interactions
            let _ = appState.isRecording
            let _ = appState.showListeningIndicator
            let _ = appState.transcriptionText
            let _ = appState.getCurrentShortcutString()
            
            // Simulate state changes
            if interactionCount % 10 == 0 {
                appState.toggleRecording()
            }
            
            if interactionCount % 15 == 0 {
                appState.hideListeningIndicator()
            }
            
            interactionCount += 1
            
            if interactionCount >= targetInteractions {
                memoryTestCompleted.fulfill()
            } else {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.01) {
                    performUIInteraction()
                }
            }
        }
        
        performUIInteraction()
        
        wait(for: [memoryTestCompleted], timeout: 5.0)
        
        // If we reach here without memory issues or crashes, test passes
        XCTAssertGreaterThanOrEqual(interactionCount, targetInteractions)
    }
}